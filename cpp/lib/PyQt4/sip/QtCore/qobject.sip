// qobject.sip generated by MetaSIP on Fri Oct 23 13:52:31 2009
//
// This file is part of the QtCore Python extension module.
//
// Copyright (c) 2009 Riverbank Computing Limited <info@riverbankcomputing.com>
// 
// This file is part of PyQt.
// 
// This file may be used under the terms of the GNU General Public
// License versions 2.0 or 3.0 as published by the Free Software
// Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
// included in the packaging of this file.  Alternatively you may (at
// your option) use any later version of the GNU General Public
// License if such license has been publicly approved by Riverbank
// Computing Limited (or its successors, if any) and the KDE Free Qt
// Foundation. In addition, as a special exception, Riverbank gives you
// certain additional rights. These rights are described in the Riverbank
// GPL Exception version 1.1, which can be found in the file
// GPL_EXCEPTION.txt in this package.
// 
// Please review the following information to ensure GNU General
// Public Licensing requirements will be met:
// http://trolltech.com/products/qt/licenses/licensing/opensource/. If
// you are unsure which license is appropriate for your use, please
// review the following information:
// http://trolltech.com/products/qt/licenses/licensing/licensingoverview
// or contact the sales department at sales@riverbankcomputing.com.
// 
// This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.


class QWidget /External/;
typedef QList<QObject*> QObjectList;

class QObject /Supertype=sip.wrapper/
{

%TypeHeaderCode
#include <qobject.h>
%End

%TypeCode
// This is needed by the tr() and trUt8() handwritten implementations.
#include <qcoreapplication.h>


// These are the recursive helper functions for QObject::findChild() and
// QObject::findChildren.

static PyObject *qtcore_FindChild(const QObject *parent, PyObject *parent_obj, PyTypeObject *type, const QString &name)
{
    const QObjectList &children = parent->children();
    int i;

    PyObject *clist = PyList_New(children.size());

    if (!clist)
        return 0;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, parent_obj);

        if (!pyo)
        {
            Py_DECREF(clist);
            return 0;
        }

        if ((name.isNull() || obj->objectName() == name) && PyType_IsSubtype(Py_TYPE(pyo), type))
        {
            Py_DECREF(clist);
            return pyo;
        }

        PyList_SET_ITEM(clist, i, pyo);
    }

    for (i = 0; i < children.size(); ++i)
    {
        PyObject *pyo = qtcore_FindChild(children.at(i), PyList_GET_ITEM(clist, i), type, name);

        if (pyo != Py_None)
        {
            Py_DECREF(clist);
            return pyo;
        }

        Py_DECREF(pyo);
    }

    Py_DECREF(clist);

    Py_INCREF(Py_None);
    return Py_None;
}

static int qtcore_FindChildren(const QObject *parent, PyObject *parent_obj, PyTypeObject *type, const QString &name, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, parent_obj);

        if (!pyo)
            return -1;

        if ((name.isNull() || obj->objectName() == name) && PyType_IsSubtype(Py_TYPE(pyo), type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        int rc = qtcore_FindChildren(obj, pyo, type, name, list);

        Py_DECREF(pyo);

        if (rc < 0)
            return -1;
    }

    return 0;
}

static int qtcore_FindChildren(const QObject *parent, PyObject *parent_obj, PyTypeObject *type, const QRegExp &re, PyObject *list)
{
    const QObjectList &children = parent->children();
    int i;

    for (i = 0; i < children.size(); ++i)
    {
        QObject *obj = children.at(i);
        PyObject *pyo = sipConvertFromType(obj, sipType_QObject, parent_obj);

        if (!pyo)
            return -1;

        if (re.indexIn(obj->objectName()) >= 0 && PyType_IsSubtype(Py_TYPE(pyo), type))
            if (PyList_Append(list, pyo) < 0)
            {
                Py_DECREF(pyo);
                return -1;
            }

        int rc = qtcore_FindChildren(obj, pyo, type, re, list);

        Py_DECREF(pyo);

        if (rc < 0)
            return -1;
    }

    return 0;
}
%End

%ConvertToSubClassCode
    static struct class_graph {
        const char *name;
        sipTypeDef **type;
        int yes, no;
    } graph[] = {
        {sipName_QAbstractEventDispatcher, &sipType_QAbstractEventDispatcher, -1, 1},
        {sipName_QEventLoop, &sipType_QEventLoop, -1, 2},
        {sipName_QTranslator, &sipType_QTranslator, -1, 3},
        {sipName_QSignalMapper, &sipType_QSignalMapper, -1, 4},
        {sipName_QObjectCleanupHandler, &sipType_QObjectCleanupHandler, -1, 5},
    #if QT_VERSION >= 0x040200
        {sipName_QFileSystemWatcher, &sipType_QFileSystemWatcher, -1, 6},
    #else
        {0, 0, -1, 6},
    #endif
        {sipName_QSocketNotifier, &sipType_QSocketNotifier, -1, 7},
        {sipName_QPluginLoader, &sipType_QPluginLoader, -1, 8},
        {sipName_QIODevice, &sipType_QIODevice, 19, 9},
        {sipName_QLibrary, &sipType_QLibrary, -1, 10},
        {sipName_QThread, &sipType_QThread, -1, 11},
        {sipName_QCoreApplication, &sipType_QCoreApplication, -1, 12},
    #if QT_VERSION >= 0x040200
        {sipName_QTimeLine, &sipType_QTimeLine, -1, 13},
    #else
        {0, 0, -1, 13},
    #endif
    #if QT_VERSION >= 0x040400
        {sipName_QSharedMemory, &sipType_QSharedMemory, -1, 14},
    #else
        {0, 0, -1, 14},
    #endif
        {sipName_QAbstractItemModel, &sipType_QAbstractItemModel, 23, 15},
        {sipName_QSettings, &sipType_QSettings, -1, 16},
    #if QT_VERSION >= 0x040400
        {sipName_QThreadPool, &sipType_QThreadPool, -1, 17},
    #else
        {0, 0, -1, 17},
    #endif
        {sipName_QTimer, &sipType_QTimer, -1, 18},
        {sipName_QMimeData, &sipType_QMimeData, -1, -1},
        {sipName_QFile, &sipType_QFile, 22, 20},
        {sipName_QProcess, &sipType_QProcess, -1, 21},
        {sipName_QBuffer, &sipType_QBuffer, -1, -1},
        {sipName_QTemporaryFile, &sipType_QTemporaryFile, -1, -1},
        {sipName_QAbstractListModel, &sipType_QAbstractListModel, -1, 24},
        {sipName_QAbstractTableModel, &sipType_QAbstractTableModel, -1, -1},
    };
    
    int i = 0;
    
    sipType = 0;
    
    do
    {
        struct class_graph *cg = &graph[i];
    
        if (cg->name != NULL && sipCpp->inherits(cg->name))
        {
            sipType = *cg->type;
            i = cg->yes;
        }
        else
            i = cg->no;
    }
    while (i >= 0);
%End

public:
    static const QMetaObject staticMetaObject;
%GetCode
        sipPy = qpycore_qobject_staticmetaobject(sipPyType);
%End

    const QMetaObject *metaObject() const;
    explicit QObject(QObject *parent /TransferThis/ = 0);
    virtual ~QObject();
    void pyqtConfigure(SIP_PYOBJECT) /NoArgParser/;
%MethodCode
        // Check there are no positional arguments.
        if (PyTuple_Size(sipArgs) > 0)
        {
            PyErr_SetString(PyExc_TypeError, "QObject.pyqtConfigure() has no positional arguments");
            return 0;
        }
        
        // Get the QObject self.
        void *qobj = sipGetCppPtr((sipSimpleWrapper *)sipSelf, sipType_QObject);
        
        if (!qobj)
            return 0;
        
        // Configure it and raise an exception if any aren't known.
        if (qpycore_pyqtconfigure(sipSelf, reinterpret_cast<QObject *>(qobj), sipKwds) < 0)
            return 0;
        
        Py_INCREF(Py_None);
        return Py_None;
%End

    virtual bool event(QEvent *);
    virtual bool eventFilter(QObject *, QEvent *);
%If (Qt_4_2_0 -)
    QString tr(SIP_PYOBJECT sourceText, const char *comment = 0, int n = -1) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::CodecForTr);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::CodecForTr, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%If (- Qt_4_2_0)
    QString tr(SIP_PYOBJECT sourceText, const char *comment = 0) const;
%MethodCode
        // Note that tr() is really a static method.  We pretend it isn't so we can use
        // self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::DefaultCodec);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::DefaultCodec));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsLatin1String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromLatin1(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
%If (Qt_4_2_0 -)
    QString trUtf8(SIP_PYOBJECT sourceText, const char *comment = 0, int n = -1) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
        if (source)
        {
            sipRes = new QString(QCoreApplication::translate(Py_TYPE(sipSelf)->tp_name,
                    source, a1, QCoreApplication::UnicodeUTF8, a2));
            Py_DECREF(a0);
        }
        else
        {
            sipIsErr = 1;
        }
%End

%End
%If (- Qt_4_2_0)
    QString trUtf8(SIP_PYOBJECT sourceText, const char *comment = 0) const;
%MethodCode
        // Note that trUtf8() is really a static method.  We pretend it isn't aren't so
        // we can use self to get hold of the class name.
        
        if (QCoreApplication::instance())
        {
            const char *source = qpycore_encode(&a0, QCoreApplication::UnicodeUTF8);
        
            if (source)
            {
                sipRes = new QString(QCoreApplication::instance()->translate(Py_TYPE(sipSelf)->tp_name, source, a1, QCoreApplication::UnicodeUTF8));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
        else
        {
            const char *source = sipString_AsUTF8String(&a0);
        
            if (source)
            {
                sipRes = new QString(QString::fromUtf8(source));
                Py_DECREF(a0);
            }
            else
            {
                sipIsErr = 1;
            }
        }
%End

%End
    SIP_PYOBJECT findChild(SIP_PYTYPE type, const QString &name = QString()) const;
%MethodCode
        sipRes = qtcore_FindChild(sipCpp, sipSelf, (PyTypeObject *)a0, *a1);
        
        if (!sipRes)
            sipIsErr = 1;
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QString &name = QString()) const;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, sipSelf, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    SIP_PYLIST findChildren(SIP_PYTYPE type, const QRegExp &regExp) const;
%MethodCode
        if ((sipRes = PyList_New(0)) == NULL || qtcore_FindChildren(sipCpp, sipSelf, (PyTypeObject *)a0, *a1, sipRes) < 0)
        {
            Py_XDECREF(sipRes);
            sipIsErr = 1;
        }
%End

    void emit(SIP_SIGNAL, ...) const;
%MethodCode
        if (!qpycore_qobject_emit(sipCpp, a0, a1))
            sipIsErr = 1;
%End

    QString objectName() const;
    void setObjectName(const QString &name);
    bool isWidgetType() const;
    bool signalsBlocked() const;
    bool blockSignals(bool b);
    QThread *thread() const;
    void moveToThread(QThread *thread);
    int startTimer(int interval);
    void killTimer(int id);
    const QObjectList &children() const;
    void setParent(QObject * /TransferThis/);
    void installEventFilter(QObject *);
    void removeEventFilter(QObject *);
    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection);
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, a3, (int)a4);
%End

    static SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE, Qt::ConnectionType=Qt::AutoConnection);
%MethodCode
        sipRes = sipConnectRx(a0, a1, a2, 0, (int)a3);
%End

    SIP_PYOBJECT connect(SIP_QOBJECT, SIP_SIGNAL, SIP_SLOT, Qt::ConnectionType=Qt::AutoConnection) const;
%MethodCode
        sipRes = sipConnectRx(a0, a1, sipSelf, a2, (int)a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_QOBJECT, SIP_SLOT);
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, a3);
%End

    static SIP_PYOBJECT disconnect(SIP_QOBJECT, SIP_SIGNAL, SIP_PYCALLABLE);
%MethodCode
        sipRes = sipDisconnectRx(a0, a1, a2, 0);
%End

    void dumpObjectInfo();
    void dumpObjectTree();
%If (Qt_4_2_0 -)
    QList<QByteArray> dynamicPropertyNames() const;
%End
    bool setProperty(const char *name, const QVariant &value);
    QVariant property(const char *name) const;

signals:
    void destroyed(QObject * = 0);

public:
    QObject *parent() const;
    bool inherits(const char *classname) const;

public slots:
    void deleteLater() /TransferThis/;

public:
    QObject *sender() const;
%MethodCode
        // This is actually protected but we never need to call the real method.
        
        sipRes = qpycore_qobject_sender();
%End

protected:
    int receivers(SIP_SIGNAL signal) const;
%MethodCode
        // We need to take into account any proxies for Python signals. Import the
        // helper if it hasn't already been done.
        typedef int (*helper_func)(QObject *, const char *, int);
        
        static helper_func helper = 0;
        
        if (!helper)
            helper = (helper_func)sipImportSymbol("qpycore_qobject_receivers");
        
        if (helper)
            sipRes = helper(sipCpp, a0, sipCpp->sipProtect_receivers(a0));
%End

    virtual void timerEvent(QTimerEvent *);
    virtual void childEvent(QChildEvent *);
    virtual void customEvent(QEvent *);
    virtual void connectNotify(SIP_SIGNAL signal);
    virtual void disconnectNotify(SIP_SIGNAL signal);

private:
    QObject(const QObject &);
};

SIP_PYOBJECT Q_ENUMS(...);
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT Q_FLAGS(...);
%MethodCode
    sipRes = qpycore_register_int_types(a0);
%End

SIP_PYOBJECT QT_TR_NOOP(SIP_PYOBJECT);
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TR_NOOP_UTF8(SIP_PYOBJECT);
%MethodCode
    Py_INCREF(a0);
    sipRes = a0;
%End

SIP_PYOBJECT QT_TRANSLATE_NOOP(SIP_PYOBJECT, SIP_PYOBJECT);
%MethodCode
    Py_INCREF(a1);
    sipRes = a1;
%End

SIP_PYOBJECT SLOT(const char * /Encoding="ASCII"/);
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('1');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT SIGNAL(const char * /Encoding="ASCII"/);
%MethodCode
    QByteArray ns = QMetaObject::normalizedSignature(a0);
    ns.prepend('2');
    
    if ((sipRes = SIPBytes_FromString(ns.constData())) == NULL)
        sipIsErr = 1;
%End

SIP_PYOBJECT pyqtSlot(const char *signature, const char *result = 0) /NoArgParser/;
%MethodCode
    return qpycore_pyqtslot(sipArgs, sipKwds);
%End

SIP_PYOBJECT pyqtSignature(const char *signature, const char *result = 0) /NoArgParser/;
%MethodCode
    return qpycore_pyqtsignature(sipArgs, sipKwds);
%End

%ModuleHeaderCode
#include <qpycore_api.h>
%End

%ModuleCode
// These optional parts of the legacy Qt support API for SIP are implemented.
// This cannot go into qpycore_api.h as they need to be in a particular
// position in the generated code.

#undef sipQtCreateUniversalSignal
#undef sipQtFindUniversalSignal

extern "C"
{
    void *sipQtCreateUniversalSignal(void *tx, const char **sig);
    void *sipQtFindUniversalSignal(void *tx, const char **sig);
    void *sipQtCreateUniversalSlot(sipWrapper *tx, const char *sig,
            PyObject *rxObj, const char *slot, const char **member, int flags);
    void sipQtDestroyUniversalSlot(void *rx);
    void *sipQtFindSlot(void *tx, const char *sig, PyObject *rxObj,
            const char *slot, const char **member);
    int sipQtConnect(void *tx, const char *sig, void *rx, const char *slot,
            int type);
    int sipQtDisconnect(void *tx, const char *sig, void *rx, const char *slot);
    int sipQtSameSignalSlotName(const char *s1, const char *s2);
    sipSlot *sipQtFindSipslot(void *tx, void **context);
}
%End

%InitialisationCode
qpycore_init();
%End

%PostInitialisationCode
qpycore_post_init(sipModuleDict);
%End
